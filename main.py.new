#!/usr/bin/env python3
"""
Main entry point for the Quantum Resonance Language Model.

This script provides a unified interface for training, evaluating,
compressing, and generating text with the model.
"""

import sys
import os
import argparse
import logging
from typing import Dict, Any, Optional

from src.cli.arg_parsing import parse_args, create_parser_for_mode, infer_mode_from_args
from src.cli.commands import train_command, evaluate_command, generate_command, compress_command
from src.utils.logging import setup_logger
from src.config.config_manager import ConfigManager


def main():
    """Main entry point."""
    # Determine mode from arguments
    mode = infer_mode_from_args()
    
    # Parse arguments for the specified mode
    args = parse_args(mode)
    
    # Set up logging
    log_level = args.log_level if hasattr(args, 'log_level') else "info"
    logger = setup_logger(
        name="quantum_resonance",
        log_level=getattr(logging, log_level.upper())
    )
    
    # Set output directory
    output_dir = args.output_dir if hasattr(args, 'output_dir') else "runs/quantum_resonance"
    os.makedirs(output_dir, exist_ok=True)
    
    # Convert args to dictionary
    args_dict = vars(args)
    
    # Create configuration manager
    config_manager = ConfigManager()
    
    # Load configuration from file if provided
    base_config = {}
    if hasattr(args, 'config_dir') and args.config_dir:
        try:
            logger.info(f"Loading configuration from {args.config_dir}")
            config_dir = args.config_dir
            
            model_config_path = os.path.join(config_dir, "model_config.json")
            training_config_path = os.path.join(config_dir, "training_config.json")
            data_config_path = os.path.join(config_dir, "data_config.json")
            
            if os.path.exists(model_config_path):
                model_config = config_manager.load_config(model_config_path)
                base_config.update(model_config)
                
            if os.path.exists(training_config_path):
                training_config = config_manager.load_config(training_config_path)
                base_config.update(training_config)
                
            if os.path.exists(data_config_path):
                data_config = config_manager.load_config(data_config_path)
                base_config.update(data_config)
                
        except Exception as e:
            logger.warning(f"Error loading configuration: {e}")
            logger.info("Using default configuration")
    
    # Override with command line arguments
    config_from_args = config_manager.from_command_line_args(args_dict)
    config = config_manager.merge_configs(base_config, config_from_args)
    
    # Execute command based on mode
    try:
        if mode == "train":
            return train_command(args_dict, config)
        elif mode == "eval":
            return evaluate_command(args_dict, config)
        elif mode == "generate":
            return generate_command(args_dict, config)
        elif mode == "compress":
            return compress_command(args_dict, config)
        else:
            logger.error(f"Unknown mode: {mode}")
            return 1
    except KeyboardInterrupt:
        logger.info("Operation interrupted by user")
        return 130  # Standard UNIX exit code for SIGINT
    except Exception as e:
        logger.error(f"Error: {e}", exc_info=True)
        return 1


if __name__ == "__main__":
    sys.exit(main())